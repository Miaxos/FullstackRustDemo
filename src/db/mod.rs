//! This module is responsible for facilitating interaction with the database.
//! Pools and Connections are defined which allow a pool to be specified at startup, and for routes to request a connection from the pool.
//! The files in this module contain functions that interact with the type specified by the filename.
//! These functions are analagous to stored procedures.
use diesel::pg::PgConnection;
use r2d2_diesel::ConnectionManager;
use r2d2;

use std::ops::Deref;
use rocket::http::Status;
use rocket::request::{self, FromRequest};
use rocket::{Request, State, Outcome};
use diesel::Insertable;
use diesel::Queryable;

pub mod user;
pub mod article;
pub mod forum;
pub mod thread;
pub mod post;
pub mod bucket;
pub mod question;
pub mod answer;

pub mod schema {
    //! Contains all of the schema data generated by Diesel.
    infer_schema!("dotenv:DATABASE_URL");
}

/// Holds a bunch of connections to the database and hands them out to routes as needed.
pub type Pool = r2d2::Pool<ConnectionManager<PgConnection>>;

pub const DATABASE_FILE: &'static str = env!("DATABASE_URL");

/// Initializes the pool.
pub fn init_pool() -> Pool {
    let config = r2d2::Config::default();
    let manager = ConnectionManager::<PgConnection>::new(DATABASE_FILE);
    r2d2::Pool::new(config, manager)
        .expect("db pool")
}

/// Wrapper for PgConnection.
/// This type can be used in route methods to grab a DB connection from the managed pool.
pub struct Conn(r2d2::PooledConnection<ConnectionManager<PgConnection>>);

impl Conn {
    #[cfg(test)]
    pub(crate) fn new(pooled_connection: r2d2::PooledConnection<ConnectionManager<PgConnection>>) -> Conn {
        Conn(pooled_connection)
    }
}

impl Deref for Conn {
    type Target = PgConnection;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<'a, 'r> FromRequest<'a, 'r> for Conn {
    type Error = ();

    // Gets the pool from the request and extracts a reference to a connection which is then wrapped in a Conn() and handed to route.
    fn from_request(request: &'a Request<'r>) -> request::Outcome<Conn, ()> {
        let pool = match <State<Pool> as FromRequest>::from_request(request) {
            Outcome::Success(pool) => pool,
            Outcome::Failure(e) => return Outcome::Failure(e),
            Outcome::Forward(_) => return Outcome::Forward(()),
        };

        match pool.get() {
            Ok(conn) => Outcome::Success(Conn(conn)),
            Err(_) => Outcome::Failure((Status::ServiceUnavailable, ())),
        }
    }
}

use error::WeekendAtJoesError;
use diesel::pg::Pg;
use diesel::Identifiable;


pub trait Creatable<'a, W, S, T: 'a> {
    fn create(insert: T, conn: &Conn) -> Result<Self, WeekendAtJoesError>
    where
        Self: Sized + Queryable<W, Pg>,
        &'a T: Insertable<S>;
}

pub trait Retrievable<'a, W> {
    fn get_by_id(id: i32, conn: &Conn) -> Result<Self, WeekendAtJoesError>
    where
        Self: 'a + Sized + Queryable<W, Pg>,
        &'a Self: Identifiable;
}

pub trait Deletable<'a> {
    fn delete_by_id(id: i32, conn: &Conn) -> Result<Self, WeekendAtJoesError>
    where
        Self: 'a + Sized,
        &'a Self: Identifiable;
}

/// Type tag that indicates that the tagged type can be created, retrieved, and deleted.
/// This collection of abilities means that it is safe to use in integration tests.
pub trait CRD<'a, W, S, T: 'a>
where
    Self: Creatable<'a, W, S, T> + Retrievable<'a, W> + Deletable<'a>
{
}
